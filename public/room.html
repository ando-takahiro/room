<!doctype html>
<html>
  <head>
    <title>learningthree.js boiler plate for three.js</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script src="vendor/three.js/Three.js"></script>
    <script src="vendor/three.js/Detector.js"></script>
    <!-- https://github.com/mrdoob/stats.js -->
    <script src="vendor/three.js/Stats.js"></script>

    <script src="vendor/jquery-1.7.1.min.js"></script>
    <script src="vendor/Tween.js"></script>
    <script src="vendor/socket.io-client/socket.io.min.js"></script>
    <script src="vendor/underscore-min.js"></script>
    <script src="vendor/mustache.min.js"></script>
    <script src="js/math.js"></script>
    <script src="js/controller.js"></script>

    <link  href="css/main.css" rel="stylesheet"/>
  </head>
  <body>
    <!-- three.js container -->
    <div id="container"></div>

    <script type="text/javascript">

// based on: browserify
function EventEmitter() {}
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.toString.call(xs) === '[object Array]'
    }
;

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = list.indexOf(listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

      var stats, scene, renderer, camera, guiEvents = new EventEmitter();

      if (!init()) {
        TWEEN.start();
        animate();
      }

      // init the scene
      function init(){
        setupEnv();
        setupGround();
        setupClient();
      }

      // animation loop
      function animate() {
        // loop on request animation loop
        // - it has to be at the begining of the function
        // - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
        requestAnimationFrame(animate);

        // do the render
        render();

        // update stats
        stats.update();
      }

      // render the scene
      function render() {
        // actually render the scene
        renderer.render(scene, camera);
      }

      //
      // logger
      //
      function Logger() {
        this.logs = [];
      }

      Logger.prototype.restore = function(id, dom) {
        this.id = id;
        this.dom = dom;
        this.dom.html('');
        for (var i = 0; i < this.logs.length; i++) {
          this._show(this.logs[i]);
        }
      };

      Logger.prototype._show = function(msg) {
        this.dom.prepend(Mustache.to_html($('#log-template').html(), msg));
      };

      Logger.prototype.push = function(msg) {
        if (typeof msg === 'string') {
          msg = {message: msg};
        } else {
          msg = _.clone(msg);
        }
        _.defaults(msg, {
          date: +new Date(),
          user: this.id
        });

        this.logs.push(msg);

        if (this.dom) {
          this._show(msg);
        }
      };
      
      var _logger = new Logger();
      function log(msg) {
        _logger.push(msg);
      }
      guiEvents.on('hear', function(msg) {
        log(_.extend(msg, {type: 'chat'}));
      });

      //
      // setuppers
      //

      function setupEnv() {
        if (Detector.webgl) {
          renderer = new THREE.WebGLRenderer({
            antialias: true,	// to get smoother output
            preserveDrawingBuffer: true	// to allow screenshot
          });
          renderer.setClearColorHex(0xBBBBBB, 1);
        // uncomment if webgl is required
        //}else{
        //	Detector.addGetWebGLMessage();
        //	return true;
        } else {
          renderer	= new THREE.CanvasRenderer();
        }
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // add Stats.js - https://github.com/mrdoob/stats.js
        stats = new Stats();
        stats.domElement.style.position	= 'absolute';
        stats.domElement.style.bottom	= '0px';
        document.body.appendChild(stats.domElement);

        // create a scene
        scene = new THREE.Scene();

        // put a camera in the scene
        camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 5, 5);
        camera.lookAt(new THREE.Vector3());
        scene.add(camera);
      }

      function setupGround() {
        var geometry = new THREE.PlaneGeometry(100, 100),
            material = new THREE.MeshBasicMaterial({color: 0xFFFFFF}),
            mesh = new THREE.Mesh(geometry, material);

        mesh.rotation.x = -0.5 * Math.PI;
        mesh.position.y = -0.5;
        scene.add(mesh);
      }

      function setupToolbox(entity) {
        var $toolbox = $(Mustache.to_html($('#toolbox-template').html(), {
          avatar: entity.avatar,
          id: entity.id
        }));

        _logger.restore(entity.id, $toolbox.find('#logs'));
        $('body').append($toolbox);
      }

      function setupClient() {
        controller.createClient(io.connect(), localStorage, scene, guiEvents, function(client, localAvatar) {
          setupToolbox(localAvatar.entity);

          var projector = new THREE.Projector();
          $('body').on('click', function(ev) {
            var mouseX = +(ev.clientX / window.innerWidth) * 2 - 1,
                mouseY = -(ev.clientY / window.innerHeight) * 2 + 1,
                vector = new THREE.Vector3(mouseX, mouseY, -1);

            projector.unprojectVector(vector, camera);
            vector.subSelf(camera.position).normalize();

            var moveTo = math.intersectRayAndPlane(
              camera.position, vector,
              math.plane(
                math.v3(0, 0.5, 0), math.v3(0, 1, 0)
              )
            );

            localAvatar.move(moveTo);
            client.move(moveTo);
          });
        });
      }

      //
      // event handlers
      //
      function speak() {
        if (event.keyCode === 10 || event.keyCode === 13) {
          var $this = $(event.target);
          guiEvents.emit('say', $this.val());
          $this.val('');
        }
      }
    </script>

    <script id='toolbox-template' type='text/html'>
      <div id='toolbox' onclick='javascript:event.stopPropagation()'>
        <div class='detail'>{{id}}</div>
        <img id='face' src='{{avatar}}'> </img>
        <span class='triangle-border left'><input type='text' value='hello, everyone' onkeypress='javascript:speak()'></input></span>
        <div id='logs'> </div>
      </div>
    </script>

    <script id='log-template' type='text/html'>
      <p class='detail'>{{message}}</p>
    </script>
  </body>
</html>
